<!DOCTYPE html>
<html lang="fr" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ai-motion Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://unpkg.com/wanakana"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        gray: { 700: '#40414f', 800: '#343541', 900: '#202123' }
                    }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #565869; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #acacbe; }
        .markdown-body pre { background-color: black; padding: 10px; border-radius: 6px; overflow-x: auto; }
        .markdown-body code { font-family: monospace; }
        .markdown-body p { margin-bottom: 10px; }
        #user-input:disabled { background-color: #374151; cursor: not-allowed; opacity: 0.6; }

        @keyframes pulse-red {
            0% { color: #9ca3af; }
            50% { color: #ef4444; }
            100% { color: #9ca3af; }
        }
        .timer-warning { animation: pulse-red 2s infinite; }
    </style>
</head>
<body class="bg-gray-800 text-gray-100 flex h-screen overflow-hidden text-sm">

    <div class="hidden md:flex w-[260px] flex-col bg-gray-900 p-2">
        <button id="new-chat-desktop" class="flex items-center gap-3 rounded-md border border-white/20 p-3 text-white transition-colors duration-200 hover:bg-gray-500/10 mb-4">
            <span class="text-xl">+</span> <span class="lang-new-chat">New chat</span>
        </button>

        <div class="px-3 mb-4">
            <label class="text-xs text-gray-400 mb-1 block">Language / Langue</label>
            <select id="lang-selector" class="w-full bg-gray-800 text-white border border-gray-700 rounded p-1 text-xs focus:ring-1 focus:ring-white">
                <option value="fr">Français</option>
                <option value="en">English</option>
                <option value="ja">日本語 (Japanese)</option>
            </select>
        </div>

        <div class="mt-auto px-3 pb-4">
            <div id="timer-display" class="text-xs text-gray-400 font-mono mb-2">00:00</div>

            <button id="end-btn-desktop" class="hidden w-full items-center justify-center gap-2 rounded border border-red-500/50 bg-red-500/10 p-2 text-xs text-red-200 transition-colors hover:bg-red-500/20">
                Stop / Fin
            </button>
        </div>
    </div>

    <div class="flex flex-1 flex-col relative">
        <div class="flex items-center justify-between border-b border-white/20 bg-gray-800 p-2 text-gray-100 md:hidden">
            <div class="text-xs font-mono" id="mobile-timer">00:00</div>
            <button id="end-btn-mobile" class="hidden px-2 py-1 text-xs text-red-300 border border-red-900 rounded bg-red-900/20 mr-2">
                Fin
            </button>
            <span>Ai-motion</span>
            <button id="new-chat-mobile" class="p-2 hover:bg-gray-900 rounded">+</button>
        </div>

        <div id="chat-container" class="flex-1 overflow-y-auto w-full scroll-smooth">
            <div class="flex flex-col items-center text-sm dark:bg-gray-800">
                <div id="welcome-screen" class="flex flex-col items-center justify-center h-[80vh] text-center px-4">
                    <div class="bg-white text-gray-800 rounded-full p-4 mb-4">
                        <svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="41" width="41" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"></path></svg>
                    </div>
                    <h1 class="text-4xl font-semibold mb-4">Ai-motion</h1>
                    <p class="text-gray-400 mb-8 max-w-md lang-welcome-sub">
                        Une expérience conversationnelle sur les émotions.
                    </p>
                    <button id="start-btn" class="bg-white text-gray-800 px-6 py-2 rounded hover:bg-gray-200 transition font-medium lang-start-btn">
                        Commencer la discussion
                    </button>
                    <div id="discussion-id-display" class="text-xs text-gray-600 mt-8 font-mono"></div>
                </div>

                <div id="chat-log" class="w-full flex flex-col gap-0 pb-32 hidden"></div>
            </div>
        </div>

        <div class="absolute bottom-0 left-0 w-full bg-gradient-to-t from-gray-800 via-gray-800 to-transparent pt-10 pb-6 px-4">
            <div class="mx-auto max-w-3xl">
                <div class="relative flex h-full w-full flex-col rounded-xl border border-black/10 bg-gray-700 shadow-md dark:border-gray-900/50">
                    <textarea id="user-input" rows="1" class="m-0 w-full resize-none border-0 bg-transparent p-4 pr-10 text-white placeholder-gray-400 focus:ring-0 focus-visible:ring-0 outline-none overflow-y-hidden" placeholder="Send a message..." style="max-height: 200px;"></textarea>
                    <button id="send-btn" class="absolute bottom-2.5 right-2.5 rounded-md p-1 bg-transparent text-gray-400 hover:bg-gray-900 disabled:hover:bg-transparent disabled:opacity-40 disabled:cursor-not-allowed transition-colors">
                        <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4 mr-1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
                <div class="flex justify-between px-2 mt-1">
                     <span class="text-[10px] text-gray-500" id="typing-indicator"></span>
                     <span class="text-[10px] text-gray-500" id="char-count">0 chars</span>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-notification" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/80 text-white px-6 py-4 rounded-lg shadow-xl opacity-0 hidden text-center max-w-[80%]">
        <span id="toast-message">Minimum 25 chars</span>
    </div>

    <script>
        // CONFIGURATION
        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyy1OKjOeWc34au_H7XX9F1A9sY_zV2-INJlU0SWlX801hWd0_oEklGecRCvDr5S9D6/exec";
        const SESSION_DURATION_MS = 10 * 60 * 1000;
        const WARNING_TIME_MS = 7 * 60 * 1000;

        // --- I18N & TEXT CONTENT ---
        const I18N = {
            fr: {
                newChat: "Nouvelle discussion",
                welcomeSub: "Une expérience conversationnelle sur les émotions.",
                startBtn: "Commencer la discussion",
                placeholder: "Écrivez votre message...",
                endHint: "Dites 'au revoir' pour terminer.",
                greeting: "Bonjour ! Je suis heureux d'échanger avec vous. Comment souhaitez-vous que je vous appelle ? (Vous pouvez choisir un pseudonyme).",
                formality: (name) => `Enchanté·e ${name}. Préférez-vous que je vous dise « tu » ou « vous » ?`,
                askEmotion: (formal) => `C'est noté. Comment ${formal ? "vous sentez-vous" : "te sens-tu"} en ce moment ? (Ex: Joie, fatigue, stress...)`,
                askDescribe: (formal) => `${formal ? "Dites" : "Dis"}-m'en un peu plus. Qu'est-ce qui provoque ce sentiment ?`,
                suggestEmotion: (formal, em, trans) => `Je vois, merci pour ce partage. J'aimerais maintenant aborder une émotion différente : "${trans}". ${formal ? "La connaissez-vous" : "La connais-tu"} ?`,
                continue: (formal) => `D'accord. ${formal ? "Voudriez-vous" : "Voudrais-tu"} me raconter une situation spécifique où ${formal ? "vous avez" : "tu as"} ressenti cela ? ${formal ? "N'hésitez" : "N'hésite"} pas à détailler.`,
                alternative: (formal) => `Pas de souci. ${formal ? "Souhaitez-vous" : "Souhaites-tu"} parler d'une autre émotion ?`,
                endSuggest: (formal) => `${formal ? "Souhaitez-vous" : "Souhaites-tu"} que je propose autre chose ou préfèrez-vous arrêter ?`,
                listen: "Je vous écoute.",
                timeUpWarning: "Le temps passe vite ! Il nous reste quelques minutes.",
                timeUpFinal: "Notre temps est écoulé. Avez-vous une dernière pensée à partager avant de conclure ?",
                finalMessage: () => {
                    const url = `https://www.soscisurvey.de/aiemotion/?act=IKfSv1RRmEnJw1SJENKQRKY9&r=${state.discussionId}`;
                    return `Merci d'avoir participé ! <br><br> La suite se passe ici : <a href='${url}' target='_blank' class='underline text-blue-400'>Cliquez ici pour le questionnaire</a>`;
                },
                errBackend: "Erreur de connexion au backend IA.",
                minCharWarning: "Veuillez écrire un peu plus (au moins 25 caractères).",
            },
            en: {
                newChat: "New Chat",
                welcomeSub: "A conversational experience about emotions.",
                startBtn: "Start Conversation",
                placeholder: "Type your message...",
                endHint: "Say 'goodbye' to finish.",
                greeting: "Hello! I'm happy to chat with you. How would you like me to call you? (You can pick a nickname).",
                formality: (name) => `Nice to meet you, ${name}. How are you feeling right now?`,
                askEmotion: (formal) => `Noted. How are you feeling right now? (Joy, tired, stressed...)`,
                askDescribe: (formal) => `Tell me more. What is causing this feeling?`,
                suggestEmotion: (formal, em, trans) => `Thank you for sharing that. I would like to explore a different emotion with you now: "${em}". Are you familiar with it?`,
                continue: (formal) => `Okay. Would you like to tell me about a specific situation where you felt this? Feel free to go into detail.`,
                alternative: (formal) => `No problem. Would you like to talk about another emotion?`,
                endSuggest: (formal) => `Would you like me to suggest something else, or shall we stop here?`,
                listen: "I'm listening.",
                timeUpWarning: "Time flies! We have a few minutes left.",
                timeUpFinal: "Our time is up. Do you have a last thought to share before we wrap up?",
                finalMessage: () => {
                    const url = `https://www.soscisurvey.de/aiemotion/?act=IKfSv1RRmEnJw1SJENKQRKY9&r=${state.discussionId}}`;
                    return `Thank you for participating! <br><br> Next step: <a href='${url}' target='_blank' class='underline text-blue-400'>Click here for the survey</a>`;
                },
                errBackend: "Error connecting to AI backend.",
                minCharWarning: "Please write a bit more (at least 25 characters).",
            },
            ja: {
                newChat: "新しいチャット",
                welcomeSub: "感情についての会話体験。",
                startBtn: "会話を始める",
                placeholder: "メッセージを入力...",
                endHint: "終了するには「終了」と言ってください。",
                greeting: "こんにちは！お話しできて嬉しいです。なんとお呼びすればいいですか？（ニックネームでも構いません）。",
                formality: (name) => `${name}さん、はじめまして。今の気分はいかがですか？`,
                askEmotion: (formal) => `了解しました。今の気分はいかがですか？（喜び、疲れ、ストレスなど）`,
                askDescribe: (formal) => `もう少し詳しく教えてください。その気持ちの原因は何ですか？`,
                suggestEmotion: (formal, em, trans) => `共有していただきありがとうございます。では、少し違う感情について話してみましょう。「${em}」という感情はご存知ですか？`,
                continue: (formal) => `わかりました。実際にその感情を抱いた具体的な場面について教えていただけますか？詳しく書いていただいて構いません。`,
                alternative: (formal) => `わかりました。別の感情について話しますか？`,
                endSuggest: (formal) => `他の提案をしましょうか？それともここで終わりますか？`,
                listen: "聞いています。",
                timeUpWarning: "時間が経つのは早いですね！残り数分です。",
                timeUpFinal: "時間が来ました。最後に何か共有したい思いはありますか？",
                finalMessage: () => {
                    const url = `https://www.soscisurvey.de/aiemotion/?act=IKfSv1RRmEnJw1SJENKQRKY9&r=${state.discussionId}`;
                    return `ご参加ありがとうございました！ <br><br> 次のステップ: <a href='${url}' target='_blank' class='underline text-blue-400'>アンケートはこちら</a>`;
                },
                errBackend: "AIバックエンドへの接続エラー。",
                minCharWarning: "もう少し長く書いてください（25文字以上）。",
            }
        };

        const EMOTIONS_LIST = [
            "admiration", "adoration", "aesthetic appreciation", "amusement", "anger", "anxiety", "awe", "awkwardness", "boredom", "calmness", "confusion", "craving", "disgust", "empathic pain", "entrancement", "excitement", "fear", "horror", "interest", "joy", "nostalgia", "relief", "romance", "sadness", "satisfaction", "neutral", "surprise"
        ];

        const FR_EMOTION_MAP = {
            "admiration": "admiration", "adoration": "adoration", "aesthetic appreciation": "appréciation esthétique", "amusement": "amusement", "anger": "colère", "anxiety": "anxiété", "awe": "émerveillement", "awkwardness": "gêne", "boredom": "ennui", "calmness": "calme", "confusion": "confusion", "craving": "envie", "disgust": "dégoût", "empathic pain": "douleur empathique", "entrancement": "fascination", "excitement": "excitation", "fear": "peur", "horror": "horreur", "interest": "intérêt", "joy": "joie", "nostalgia": "nostalgie", "relief": "soulagement", "romance": "romance", "sadness": "tristesse", "satisfaction": "satisfaction", "neutral": "neutre", "surprise": "surprise"
        };

        const STEPS = {
            GREETING: 1, CAPTURE_NICKNAME: 2, FORMALITY: 3, EMOTION_ASK: 4, EMOTION_DESCRIBE: 5,
            EMOTION_SUGGEST: 6, SITUATION_ASK: 7, NATURAL_CONVERSATION: 8,
            EMOTION_ALTERNATIVE: 11, END_OR_SUGGEST: 12, LAST_TURN: 98, END: 99
        };

        // --- DOM ELEMENTS ---
        const chatLog = document.getElementById('chat-log');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const welcomeScreen = document.getElementById('welcome-screen');
        const startBtn = document.getElementById('start-btn');
        const langSelector = document.getElementById('lang-selector');
        const timerDisplay = document.getElementById('timer-display');
        const mobileTimer = document.getElementById('mobile-timer');
        const charCount = document.getElementById('char-count');

        // --- STATE MANAGEMENT ---
        let state = {
            discussionId: null,
            utteranceCount: 0,
            step: STEPS.GREETING,
            nickname: null,
            useFormal: true,
            emotion: null,
            history: [],
            llmTurnCount: 0,
            startTime: null,
            lang: 'fr',
            timerInterval: null,
            warningSent: false,
            pendingTimeUp: false
        };

        // --- INIT & LOCAL STORAGE ---
        function init() {
            // Restore from localStorage if exists
            const saved = localStorage.getItem('ai_motion_state');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (parsed.step !== STEPS.END) {
                        state = parsed;
                        restoreChatLog();
                        if(state.startTime) startTimer(false);
                        updateLanguageUI();
                        updateEndButtonVisibility();

                        if(state.history.length > 0) {
                            welcomeScreen.classList.add('hidden');
                            chatLog.classList.remove('hidden');
                        }
                    } else {
                        resetState();
                    }
                } catch(e) { console.error("Load error", e); resetState(); }
            } else {
                resetState();
            }
        }

        function resetState() {
            state = {
                discussionId: crypto.randomUUID(),
                utteranceCount: 0,
                step: STEPS.GREETING,
                nickname: null,
                useFormal: true,
                emotion: null,
                history: [],
                llmTurnCount: 0,
                startTime: null,
                lang: langSelector.value,
                timerInterval: null,
                warningSent: false
            };
            document.getElementById('discussion-id-display').textContent = "ID: " + state.discussionId;
        }

        function saveState() {
            const { timerInterval, ...toSave } = state;
            localStorage.setItem('ai_motion_state', JSON.stringify(toSave));
        }

        function restoreChatLog() {
            chatLog.innerHTML = '';
            state.history.forEach(msg => {
                if(msg.role !== 'system') {
                    appendMessage(msg.role, msg.content, false);
                }
            });
            document.getElementById('discussion-id-display').textContent = "ID: " + state.discussionId;
        }

        // --- LANGUAGE & TRANSLATION ---
        function t(key, ...args) {
            const langObj = I18N[state.lang] || I18N.fr;
            let val = langObj[key];
            if (typeof val === 'function') return val(...args);
            return val || key;
        }

        function updateLanguageUI() {
            const L = I18N[state.lang];
            document.querySelector('.lang-new-chat').textContent = L.newChat;
            document.querySelector('.lang-welcome-sub').textContent = L.welcomeSub;
            document.querySelector('.lang-start-btn').textContent = L.startBtn;
            document.querySelector('.lang-end-hint').textContent = L.endHint;
            userInput.placeholder = L.placeholder;

        }

        langSelector.addEventListener('change', (e) => {
            state.lang = e.target.value;
            updateLanguageUI();
            if (state.utteranceCount === 0) resetChat();
        });

        // --- TIMER ---
        function startTimer(reset = true) {
            if (reset) {
                state.startTime = Date.now();
                state.warningSent = false;
                state.pendingTimeUp = false;
            }
            if (state.timerInterval) clearInterval(state.timerInterval);

            state.timerInterval = setInterval(() => {
                if (!state.startTime) return;

                const elapsed = Date.now() - state.startTime;
                const remaining = Math.max(0, SESSION_DURATION_MS - elapsed);

                const m = Math.floor(remaining / 60000);
                const s = Math.floor((remaining % 60000) / 1000);
                const text = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;

                timerDisplay.textContent = text;
                mobileTimer.textContent = text;

                if (elapsed > WARNING_TIME_MS) {
                    timerDisplay.classList.add('timer-warning');

                    if (!state.warningSent) {
                        state.warningSent = true;
                        injectSystemMessage(t('timeUpWarning'));
                    }
                }

                if (remaining <= 0 && state.step !== STEPS.LAST_TURN && state.step !== STEPS.END) {
                    if (userInput.value.trim().length > 0) {
                        state.pendingTimeUp = true;
                    } else {
                        triggerTimeUpSequence();
                    }
                }
            }, 1000);
        }

        function triggerTimeUpSequence() {
             if(state.timerInterval) clearInterval(state.timerInterval);
             state.step = STEPS.LAST_TURN;
             const msg = t('timeUpFinal');
             // On force ce message système
             processTurn(null, msg);
             state.pendingTimeUp = false;
        }

        function injectSystemMessage(text) {
            state.utteranceCount++;
            appendMessage('assistant', text);
            state.history.push({ role: 'assistant', content: text });
            logToSheet(state.discussionId, state.utteranceCount, text).catch(console.error);
            saveState();
        }

        // --- CORE LOGIC ---
        function getResponseLogic(userMessage) {
            const msg = userMessage ? userMessage.toLowerCase().trim() : "";

            const isAffirmative = (text) => {
                const triggers = [
                    "oui", "yes", "hai", "はい",
                    "ouais", "si", "effectivement", "absolument", "bien sûr", "bien sur",
                    "ça me dit", "ca me dit", "je connais", "déjà ressenti", "déjà vécu",
                    "yeah", "yep", "sure", "of course", "familiar", "i know", "indeed", "absolutely", "I know", "already felt", "already experienced",
                    "うん","ああ","もちろん","知っている","知ってるよ","確かに","絶対に","知ってる","すでに感じた","すでに経験した"
                ];
                return triggers.some(t => text.includes(t));
            };

            if (state.step === STEPS.LAST_TURN) {
                 state.step = STEPS.END;
                 return { text: t('finalMessage'), useLLM: false };
            }

            if (state.step === STEPS.GREETING) {
                state.step = STEPS.CAPTURE_NICKNAME;
                startTimer(true);
                return { text: t('greeting'), useLLM: false };
            }

            if (state.step === STEPS.CAPTURE_NICKNAME) {
                state.nickname = extractName(userMessage, state.lang);

                if (state.lang === 'en') {
                     state.useFormal = false;
                     state.step = STEPS.EMOTION_ASK;
                     return { text: t('formality', state.nickname), useLLM: false };
                } else if (state.lang === 'ja') {
                     state.useFormal = true;
                     state.step = STEPS.EMOTION_ASK;
                     return { text: t('formality', state.nickname), useLLM: false };
                } else {
                     state.step = STEPS.FORMALITY;
                     return { text: t('formality', state.nickname), useLLM: false };
                }
            }

            if (state.step === STEPS.FORMALITY) {
                state.useFormal = !msg.includes("tu") && !msg.includes("tutoie");
                state.step = STEPS.EMOTION_ASK;
                return { text: t('askEmotion', state.useFormal), useLLM: false };
            }

            if (state.step === STEPS.EMOTION_ASK) {
                state.step = STEPS.EMOTION_DESCRIBE;
                return { text: t('askDescribe', state.useFormal), useLLM: false };
            }

            if (state.step === STEPS.EMOTION_DESCRIBE) {
                const rnd = EMOTIONS_LIST[Math.floor(Math.random() * EMOTIONS_LIST.length)];
                state.emotion = rnd;
                const translatedEm = (state.lang === 'fr' && FR_EMOTION_MAP[rnd]) ? FR_EMOTION_MAP[rnd] : rnd;

                state.step = STEPS.EMOTION_SUGGEST;
                return { text: t('suggestEmotion', state.useFormal, rnd, translatedEm), useLLM: false };
            }

            if (state.step === STEPS.EMOTION_SUGGEST) {
                if (isAffirmative(msg)) {
                     state.step = STEPS.SITUATION_ASK;
                     return { text: t('continue', state.useFormal), useLLM: false };
                } else {
                     state.step = STEPS.EMOTION_ALTERNATIVE;
                     return { text: t('alternative', state.useFormal), useLLM: false };
                }
            }

            if (state.step === STEPS.EMOTION_ALTERNATIVE) {
                 if (isAffirmative(msg)) {
                     state.step = STEPS.EMOTION_DESCRIBE;
                     return { text: t('askDescribe', state.useFormal), useLLM: false };
                 } else {
                     state.step = STEPS.END_OR_SUGGEST;
                     return { text: t('endSuggest', state.useFormal), useLLM: false };
                 }
            }

            if (state.step === STEPS.SITUATION_ASK) {
                state.step = STEPS.NATURAL_CONVERSATION;
                return { text: t('listen'), useLLM: true };
            }

            state.step = STEPS.NATURAL_CONVERSATION;
            return { text: null, useLLM: true };
        }

        async function processTurn(userText = null, forceBotText = null) {
            userInput.disabled = true;
            sendBtn.disabled = true;
            welcomeScreen.classList.add('hidden');
            chatLog.classList.remove('hidden');

            if (userText) {
                state.utteranceCount++;
                appendMessage('user', userText);
                state.history.push({role: 'user', content: userText});
                logToSheet(state.discussionId, state.utteranceCount, userText).catch(console.error);
                saveState();
            }

            if (forceBotText) {
                await new Promise(r => setTimeout(r, 600));

                state.utteranceCount++;

                appendMessage('assistant', forceBotText);
                state.history.push({role: 'assistant', content: forceBotText});

                logToSheet(state.discussionId, state.utteranceCount, forceBotText).catch(console.error);

                saveState();
                resetUI();
                updateEndButtonVisibility();
                return;
            }

            const logic = getResponseLogic(userText);

            if (!logic.useLLM) {
                await new Promise(r => setTimeout(r, 600));

                state.utteranceCount++;
                appendMessage('assistant', logic.text);
                state.history.push({role: 'assistant', content: logic.text});

                logToSheet(state.discussionId, state.utteranceCount, logic.text).catch(console.error);
                saveState();

                if (state.step === STEPS.END) {
                    endChat();
                } else {
                    resetUI();
                }
                updateEndButtonVisibility();

                if (state.pendingTimeUp && state.step !== STEPS.END) {
                    setTimeout(triggerTimeUpSequence, 1000);
                }

            } else {
                const botMessageDiv = appendMessage('assistant', '<span class="animate-pulse">...</span>');
                const botContentDiv = botMessageDiv.querySelector('.markdown-body');

                try {
                    let sysPrompt = `You are a helpful, empathetic AI assistant exploring emotions. Language: ${state.lang}.`;
                    sysPrompt += ` Keep answers concise (max 3 sentences) unless asked otherwise.`;
                    sysPrompt += ` ALWAYS end with a question to the user.`;

                    if (state.nickname) sysPrompt += ` The user's name is ${state.nickname}.`;
                    if (state.lang === 'fr' && state.useFormal) sysPrompt += ` Use 'vous'.`;
                    else if (state.lang === 'fr') sysPrompt += ` Use 'tu'.`;

                    const messagesToSend = [
                        {role: 'system', content: sysPrompt},
                        ...state.history.slice(-10)
                    ];

                    const response = await fetch(GOOGLE_SCRIPT_URL, {
                        method: 'POST',
                        redirect: "follow",
                        headers: {"Content-Type": "text/plain;charset=utf-8"},
                        body: JSON.stringify({
                            action: 'chat',
                            messages: messagesToSend
                        })
                    });

                    const data = await response.json();
                    const botText = data.message ? data.message.content : (data.content || "Error");

                    botContentDiv.innerHTML = marked.parse(botText);
                    hljs.highlightAll();

                    state.utteranceCount++;
                    state.history.push({role: 'assistant', content: botText});
                    state.llmTurnCount++;

                    logToSheet(state.discussionId, state.utteranceCount, botText).catch(console.error);
                    saveState();
                    updateEndButtonVisibility();

                } catch (error) {
                    console.error(error);
                    botContentDiv.innerHTML = `<span class='text-red-400'>${t('errBackend')}</span>`;
                } finally {
                    resetUI();
                    scrollToBottom();

                    if (state.pendingTimeUp && state.step !== STEPS.END) {
                        setTimeout(triggerTimeUpSequence, 1500);
                    }
                }
            }
        }

        async function logToSheet(id, utteranceNum, text) {
             fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    action: 'log',
                    discussion_id: id,
                    utterance_number: utteranceNum,
                    message: text,
                    timestamp: new Date().toISOString()
                })
            });
        }

        function appendMessage(role, text, save = true) {
            const isUser = role === 'user';
            const bgColor = isUser ? '' : 'bg-[#444654]';
            const icon = isUser
                ? '<div class="h-8 w-8 rounded bg-purple-600 flex items-center justify-center font-bold text-xs">YOU</div>'
                : '<div class="h-8 w-8 rounded bg-green-500 flex items-center justify-center"><svg stroke="currentColor" fill="none" stroke-width="1.5" viewBox="0 0 24 24" class="h-5 w-5 text-white"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"></path></svg></div>';

            const html = `
                <div class="w-full text-gray-100 border-b border-black/10 dark:border-gray-900/50 ${bgColor}">
                    <div class="flex p-4 gap-4 text-base md:gap-6 md:max-w-2xl lg:max-w-[38rem] xl:max-w-3xl m-auto">
                        <div class="flex-shrink-0 flex flex-col relative items-end">
                            <div class="w-[30px]">${icon}</div>
                        </div>
                        <div class="relative flex-1 overflow-hidden">
                            <div class="markdown-body w-full">${marked.parse(text)}</div>
                        </div>
                    </div>
                </div>`;

            chatLog.insertAdjacentHTML('beforeend', html);
            scrollToBottom();
            return chatLog.lastElementChild;
        }

        function resetUI() {
            userInput.disabled = false;
            sendBtn.disabled = false;
            userInput.value = '';
            userInput.focus();
            charCount.textContent = "0 chars";
            window.scrollTo(0, document.body.scrollHeight);
        }

        // --- HELPER FUNCTIONS ---

        function scrollToBottom() {
            const container = document.getElementById('chat-container');
            // Small timeout ensures DOM is rendered before scrolling
            setTimeout(() => {
                container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
            }, 100);
        }

        function extractName(input, lang) {
            let text = input.trim();

            // 1. Clean starting/ending punctuation
            text = text.replace(/^[,.!?;:。]+|[,.!?;:。]+$/g, '');

            if (lang === 'fr') {
                // Expanded patterns to catch more natural phrasing
                const prefix = /^(?:bonjour|salut|coucou)?\s*,?\s*(?:je m['’]appelle|mon nom est|appelez[- ]moi|appelle[- ]moi|moi,? c['’]est|c['’]est|je suis|tu peux m['’]appeler)\s+/i;
                const separators = /\s+(?:parce que|car|puisque|mais|c['’]est-à-dire).*$/i;
                const smallEndings = /(?:[, ]+d['’]accord\??$)|(?:[, ]+hein\??$)/i;

                text = text.replace(prefix, '').replace(separators, '').replace(smallEndings, '');
            }
            else if (lang === 'en') {
                const prefix = /^(?:hello|hi|hey)?\s*,?\s*(?:my\s+name\s+is|i\s+am|i['’]m|call\s+me|please\s*,?\s*call\s+me|you\s+can\s+call\s+me|refer\s+to\s+me\s+as|it['’]s)\s+/i;
                const separators = /\s+(?:because|since|as|but).*$/i;

                text = text.replace(prefix, '').replace(separators, '');
            }
            else if (lang === 'ja') {
                const suffix = /(?:です|だよ|と(?:申|い)います|と(?:呼|よ)んで(?:ください)?|(?:\s|　)呼んで(?:ください)?)$/;
                const prefix = /^(?:私の名前は|名前は|私は)/;
                text = text.replace(suffix, '').replace(prefix, '');
            }

            // Capitalize first letter, lowercase rest (optional style choice, good for names)
            text = text.trim();
            if (text.length > 0) {
                return text.charAt(0).toUpperCase() + text.slice(1);
            }
            return text;
        }

        function updateEndButtonVisibility() {
            const desktopBtn = document.getElementById('end-btn-desktop');
            const mobileBtn = document.getElementById('end-btn-mobile');


            if (state.llmTurnCount >= 2 && state.step !== STEPS.END) {
                desktopBtn.classList.remove('hidden');
                desktopBtn.classList.add('flex');
                mobileBtn.classList.remove('hidden');
            } else {
                desktopBtn.classList.add('hidden');
                desktopBtn.classList.remove('flex');
                mobileBtn.classList.add('hidden');
            }
        }

        function triggerEndChat() {
            if (state.step === STEPS.END) return;
            state.step = STEPS.END;
            processTurn(null, t('finalMessage'));
            updateEndButtonVisibility();
        }

        function showToast(message) {
            const toast = document.getElementById('toast-notification');
            const msgSpan = document.getElementById('toast-message');

            msgSpan.textContent = message;
            toast.classList.remove('hidden');
            // Small delay to allow class removal to register before adding opacity for transition
            setTimeout(() => toast.classList.remove('opacity-0'), 10);

            // Hide after 3 seconds
            setTimeout(() => {
                toast.classList.add('opacity-0');
                setTimeout(() => toast.classList.add('hidden'), 500); // Wait for fade out
            }, 3000);
        }

        function validateInput(text) {
            // Logic: If we are in the "LLM" phases (Situation Ask or Natural Conversation)
            // We enforce the limit.
            // STEPS.SITUATION_ASK (7) -> User is answering the request to describe context
            // STEPS.NATURAL_CONVERSATION (8) -> Ongoing chat
            if (state.step === STEPS.SITUATION_ASK || state.step === STEPS.NATURAL_CONVERSATION) {
                // Ignore "fin" commands so user isn't trapped
                if (text.match(/fin|stop|bye|quit|terminer|おわり|終了/i)) return true;

                if (text.length < 25) {
                    showToast(t('minCharWarning'));
                    return false;
                }
            }
            return true;
        }

        function endChat() {
            userInput.disabled = true;
            userInput.placeholder = "Discussion terminée / Chat ended.";
            if(state.timerInterval) clearInterval(state.timerInterval);
        }

        function resetChat() {
            localStorage.removeItem('ai_motion_state');
            resetState();
            updateEndButtonVisibility();
            chatLog.innerHTML = '';
            welcomeScreen.classList.remove('hidden');
            chatLog.classList.add('hidden');
            document.getElementById('end-chat-hint').classList.add('hidden');
            if(state.timerInterval) clearInterval(state.timerInterval);
            timerDisplay.textContent = "00:00";
            timerDisplay.classList.remove('timer-warning');
            init();
        }

        // --- EVENTS ---
        sendBtn.addEventListener('click', () => {
            const text = userInput.value.trim();
            if (text) {
                if (validateInput(text)) {
                    processTurn(text);
                }
            }
        });

        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                // Important: Wanakana needs a moment to settle if converting
                setTimeout(() => {
                    const text = userInput.value.trim();
                    if (text) {
                        if (validateInput(text)) {
                            processTurn(text);
                        }
                    }
                }, 10);
            }
        });

        userInput.addEventListener('input', () => {
            charCount.textContent = userInput.value.length + " chars";
            userInput.style.height = 'auto';
            userInput.style.height = (userInput.scrollHeight) + 'px';
        });

        startBtn.addEventListener('click', () => {
             processTurn(null);
        });

        document.getElementById('new-chat-desktop').addEventListener('click', resetChat);
        document.getElementById('new-chat-mobile').addEventListener('click', resetChat);
        document.getElementById('end-btn-desktop').addEventListener('click', triggerEndChat);
        document.getElementById('end-btn-mobile').addEventListener('click', triggerEndChat);
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>